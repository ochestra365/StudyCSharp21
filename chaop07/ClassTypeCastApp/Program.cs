using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ClassTypeCastApp//이로 미루어 보았을 때, 상위 클래스의 프로그래머가 될 수록 각 객체간의 관계성을 잘 파악하고 있음을 알 수 있다. 따라서 하위클래스 프로그래머는
    //이 클래스간의 관계성을 잘 파악할 때까지 충분히 훈련하는 차원에서 기능적인 부분을 담당하는 것이다. 이것은 프로그래밍이 객체를 다루는 추상화가 높은 작업이기 때문에
    //발생하는 현상이다.
{
    class 포유류//금융사에서는 데이터베이스 관리나 소스코드제어를 한글로 한다.//최상위 클래스 (조상격)
    {
        public void 키우다()
        {
            Console.WriteLine("키우다.");
        }
    }

    class 강아지 : 포유류//포유류 강아지가 하는 기능을 정의한 클래스
    {
        public void 멍멍()
        {
            Console.WriteLine("멍멍()");
        }
    }
    
    class 고양이 : 포유류//포유류 고양이가 하는 기능을 정의한 클래스
    {
        public void 야옹()//void가 프로그램의 기능을 담당하는 구문에 속한다는 것을 알 수 있다. void는 리턴값을 도출하지 않아서 사이클의 종료를 알리는 것이기 때문이다.
        {
            Console.WriteLine("야옹");
        }
    }

    class Program//상호작용하는 것을 표현하는 필드, 현실세계로 보자면 전체적인 객체들이 상호작용하는 공간에 해당한다.
    {
        static void Main(string[] args)//계속 지속되고, 종료시 결과값이 도출될 수도 없고 의미도 가지지 않으며, 필드에 선언 및 할당하는 문자열들은 무제한이다.[]-->배열
        {
            포유류 _포유류 = new 포유류();//자기 그대로 인스턴스를 만든 것이다. 속성이 할당되어 정의된 것을 인스턴스라고 하는 듯.
            _포유류.키우다();
            강아지 두식이;

            if(_포유류 is 강아지)//형변환이 바로 된다.-->이것은 상위 클래스를 하위클래스로 형변환 해주는 것이고, 밑의 예시는 하위 클래스 인스턴스를 형변환 해주는 것이다.
            {
                두식이 = _포유류 as 강아지;
                두식이.멍멍();
            }// 이렇게 되면 추상화된 코드를 일반화적인 클래스의 코드로써 사용할 수 있기 때문에 개발자가 보다 편하게 작업할 수 있다.

            강아지 행구 = null;//행구의 존재를 확인할 수 없다.
            if(행구 is 포유류)//근데 행구에 대한 기능을 수행하는 것은 알 수가 없는 정보라서 실행할 수 없다.
            {
                Console.WriteLine("");
                행구 = new 포유류() as 강아지;
                행구.키우다();
                행구.멍멍();
            }
            // 클래스 간의 형변환은 로직의 작업 효율성을 높이기 위해서 이다.

            //인스턴스의 형변환--> 하위 클래스의 단편적인 요소를 작업할 때,
            _포유류 = new 강아지();//이것이 형변환이다. 기반 클래스에 파생 클래스가 들어갔다. @@@@@값형식이다.@@@@ 명시적

            _포유류 = new 고양이();//부모 클래스에서는 따로 묵시적 표현을 해줄 필요가 없다. 그 이유는 컴파일러가 주소를 참조하여 타고 들어가는 형식이기 때문에
            //자연스러운 컴파일에 속하기 때문이다.

            강아지 뽀삐 = (강아지)new 포유류();//그러나 자식 클래스에서 값을 선언하고 부모 클래스에 할당하려고 하니까 안된다. 그래서 묵시적 표현으로 컴파일러에 인식시켜 주는 것이다.
            //자식 클래스에서는 참조할 대상이 상위 클래스에서는 없다. 그러나 관계는 존재한다. 컴파일러는 값 참조의 방향을 알 수 없기 때문에 사용자가 알려줘서 참조 방향으로 컴파일 하는 것이다.
            //사용자와 컴파일러간의 대상에 접근하는 방식이 다른 것을 보여주는 좋은 예이다.
            고양이 로미 = (고양이)new 포유류();//작은 것에서 큰 것에 넣으려고 하니까 묵시적 표현을 해주는 것이다. @@@@참조형식@@@@이다.
            // 상위클래스를 새로운 값에 할당한다. -> 할당된 값을 하위클래스에 초기화 한다.->꼴은 상위클래스가 할당된 값을 자식클래스로 재설정해주는 것이다.
            // 이것을 형변환이라고 한다.
            //로직에 관련된 형변환(클래스나 배열)은 if is as 구문을 써주고 값형식에 대한 형변환은 위와 같은 간단한 방식을 사용한다.
            //부모 클래스의 인스턴스를 자식 클래스의 인스턴스에 넣을 수 있으나, 반대 형식은 형변환을 해야 한다.
            //상위 클래스와 하위 클래스간의 형변환과 하위 클래스의 인스턴스 형변환은 다른 것이다. 컴파일러가 이해할 수 있는 방식으로 개발자가 설정해주는 것이다.
            // 형변환의 목적은 코드를 일반화 시켜서 개발자가 보다 편하게 작업하기 위함이다.
        }
    }
}
